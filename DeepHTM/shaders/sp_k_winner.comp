#version 430

#ifndef EXTERNAL_PARAMETERS
	#define MINICOLUMNS_BINDING 0
	#define MINICOLUMN_STATES_BINDING 1
	#define WINNER_MINICOLUMNS_BINDING 2

	#define MINICOLUMNS_SIZE_X 1u
	#define MINICOLUMNS_SIZE_Y 1u
	#define MINICOLUMN_COUNT (MINICOLUMNS_SIZE_X * MINICOLUMNS_SIZE_Y)
	#define WINNER_MINICOLUMN_COUNT 1u
#endif

layout(binding = MINICOLUMNS_BINDING) buffer Minicolumns
{
	float minicolumns[];
};

layout(binding = MINICOLUMN_STATES_BINDING) buffer MinicolumnStates
{
	uint minicolumnStates[];
};

layout(binding = WINNER_MINICOLUMNS_BINDING) buffer WinnerMinicolumns
{
	uint winnerMinicolumns[];
};

//TODO: probably should someday change it to be constant
layout(local_size_x = MINICOLUMNS_SIZE_X, local_size_y = MINICOLUMNS_SIZE_Y) in;

//partially sorted
shared uint sortedMinicolumns[MINICOLUMN_COUNT];

//this is a mess

void main()
{
	const uint workGroupIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;
	const uint outputOffset = workGroupIndex * MINICOLUMN_COUNT;
	const uint localOutput = gl_LocalInvocationIndex;
	
	sortedMinicolumns[localOutput] = outputOffset + localOutput;
	minicolumnStates[outputOffset + localOutput] = 0u;

	uint activeOffset = workGroupIndex * WINNER_MINICOLUMN_COUNT;
	
	for(uint localActive = 0u; localActive < WINNER_MINICOLUMN_COUNT; localActive++)
	{
		for(uint stride = MINICOLUMN_COUNT >> 1u; stride > 0u; stride >>= 1u)
		{
			barrier();

			if(localActive <= localOutput && localOutput - localActive < stride && localOutput + stride < MINICOLUMN_COUNT && minicolumns[sortedMinicolumns[localOutput]] < minicolumns[sortedMinicolumns[localOutput + stride]])
			{
				uint tmp = sortedMinicolumns[localOutput];
				sortedMinicolumns[localOutput] = sortedMinicolumns[localOutput + stride];
				sortedMinicolumns[localOutput + stride] = tmp;
			}
		}
	}

	if(localOutput < WINNER_MINICOLUMN_COUNT)
	{
		uint winnerMinicolumn = sortedMinicolumns[localOutput];
		minicolumnStates[winnerMinicolumn] = 1u;
		winnerMinicolumns[activeOffset + localOutput] = winnerMinicolumn;
	}
}