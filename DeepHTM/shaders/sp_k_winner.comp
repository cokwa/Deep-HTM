#version 430

#ifndef EXTERNAL_PARAMETERS
	#define MINICOLUMNS_BINDING 0
	#define WINNER_MINICOLUMNS_BINDING 1

	#define MINICOLUMNS_SIZE_X 1u
	#define MINICOLUMNS_SIZE_Y 1u
	#define MINICOLUMN_COUNT (MINICOLUMNS_SIZE_X * MINICOLUMNS_SIZE_Y)
	#define WINNER_MINICOLUMN_COUNT 1u
#endif

layout(binding = MINICOLUMNS_BINDING) buffer Minicolumns
{
	float minicolumns[];
};

layout(binding = WINNER_MINICOLUMNS_BINDING) buffer WinnerMinicolumns
{
	uint winnerMinicolumns[];
};

//probably should someday change it to be constant
layout(local_size_x = MINICOLUMNS_SIZE_X, local_size_y = MINICOLUMNS_SIZE_Y) in;

//partially sorted
shared uint sortedMinicolumns[MINICOLUMN_COUNT];

//this is a mess

void main()
{
	const uint workGroupIndex = gl_WorkGroupID.x + gl_WorkGroupID.y * gl_NumWorkGroups.x;
	uint outputOffset = workGroupIndex * MINICOLUMN_COUNT;
	uint localOutput = gl_LocalInvocationIndex;
	sortedMinicolumns[localOutput] = outputOffset + localOutput;

	uint activeOffset = workGroupIndex * WINNER_MINICOLUMN_COUNT;
	
	for(uint localActive = 0u; localActive < WINNER_MINICOLUMN_COUNT; localActive++)
	{
		for(uint stride = (MINICOLUMN_COUNT - localActive + 1u) / 2u;; stride = (stride + 1u) / 2u)
		{
			barrier();

			if(localActive <= localOutput && localOutput < stride && minicolumns[sortedMinicolumns[localOutput]] < minicolumns[sortedMinicolumns[localOutput + stride]])
			{
				uint tmp = sortedMinicolumns[localOutput];
				sortedMinicolumns[localOutput] = sortedMinicolumns[localOutput + stride];
				sortedMinicolumns[localOutput + stride] = tmp;
			}

			if(stride <= 1u)
			{
				break;
			}
		}
	}

	if(localOutput < WINNER_MINICOLUMN_COUNT)
	{
		winnerMinicolumns[activeOffset + localOutput] = sortedMinicolumns[localOutput];
	}
}